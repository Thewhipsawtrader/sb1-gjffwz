import { Request, Response } from 'express';
import asyncHandler from 'express-async-handler';
import { z } from 'zod';
import { Report } from '../models/Report';
import { AppError } from '../utils/appError';
import { logger } from '../utils/logger';
import { EmailService } from '../services/email.service';
import { WhatsAppService } from '../services/whatsapp.service';
import { ErrorCollectionService } from '../services/errorCollection.service';
import { BillingService } from '../services/billing.service';

const reportPeriodSchema = z.object({
  startDate: z.string().transform(str => new Date(str)),
  endDate: z.string().transform(str => new Date(str)),
});

export const generateDailyReport = asyncHandler(async (req: Request, res: Response) => {
  const { userId } = req.auth;
  const period = reportPeriodSchema.parse(req.body);

  logger.info('Generating daily report', {
    userId,
    period,
  });

  // Get error statistics
  const errorService = ErrorCollectionService.getInstance();
  const errorReport = errorService.getErrorReport(period.startDate, period.endDate);

  // Generate report
  const report = await Report.create({
    type: 'DAILY',
    period,
    summary: {
      totalErrors: errorReport.errors.length,
      errorsByCategory: errorReport.providers,
      errorsBySeverity: Object.fromEntries(
        ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'].map(severity => [
          severity,
          errorReport.errors.filter(e => e.severity === severity).length,
        ])
      ),
      resolvedErrors: errorReport.errors.filter(e => e.resolved).length,
    },
    details: errorReport.errors.map(error => ({
      errorId: error.id,
      message: error.message,
      severity: error.severity,
      timestamp: error.timestamp,
    })),
    metadata: {
      generatedBy: userId,
      version: '1.0.0',
    },
  });

  // Send notifications
  await Promise.all([
    EmailService.getInstance().sendDailyReport(report),
    WhatsAppService.getInstance().sendDailyReport(
      report.summary.totalErrors - report.summary.resolvedErrors,
      report.summary.resolvedErrors,
      errorReport.errors
        .filter(e => !e.resolved)
        .map(e => ({
          type: e.category,
          message: e.message,
          timestamp: e.timestamp,
        }))
    ),
  ]);

  res.json({
    status: 'success',
    data: report,
  });
});

export const generateMonthlyReport = asyncHandler(async (req: Request, res: Response) => {
  const { userId } = req.auth;
  const period = reportPeriodSchema.parse(req.body);

  logger.info('Generating monthly report', {
    userId,
    period,
  });

  // Get error statistics
  const errorService = ErrorCollectionService.getInstance();
  const errorReport = errorService.getErrorReport(period.startDate, period.endDate);

  // Calculate billing
  const billingService = BillingService.getInstance();
  const billing = billingService.calculateProviderBill(
    'ALL',
    errorReport.errors.length
  );

  // Generate report
  const report = await Report.create({
    type: 'MONTHLY',
    period,
    summary: {
      totalErrors: errorReport.errors.length,
      totalCost: billing.totalCost,
      errorsByCategory: errorReport.providers,
      errorsBySeverity: Object.fromEntries(
        ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'].map(severity => [
          severity,
          errorReport.errors.filter(e => e.severity === severity).length,
        ])
      ),
      resolvedErrors: errorReport.errors.filter(e => e.resolved).length,
    },
    details: errorReport.errors.map(error => ({
      errorId: error.id,
      message: error.message,
      severity: error.severity,
      timestamp: error.timestamp,
    })),
    billing: {
      totalAmount: billing.totalCost,
      breakdown: billing.breakdown,
    },
    metadata: {
      generatedBy: userId,
      version: '1.0.0',
    },
  });

  // Send notifications
  await Promise.all([
    EmailService.getInstance().sendMonthlyReport(report),
    WhatsAppService.getInstance().sendMessage(
      `ðŸ“Š Monthly Report Generated\n` +
      `â€¢ Period: ${period.startDate.toLocaleDateString()} - ${period.endDate.toLocaleDateString()}\n` +
      `â€¢ Total Errors: ${report.summary.totalErrors}\n` +
      `â€¢ Total Cost: R${report.billing.totalAmount.toFixed(2)}\n` +
      `â€¢ Generated by: ${userId}`
    ),
  ]);

  res.json({
    status: 'success',
    data: report,
  });
});

export const getReportHistory = asyncHandler(async (req: Request, res: Response) => {
  const reports = await Report.find()
    .sort({ 'period.startDate': -1 })
    .limit(100);

  res.json({
    status: 'success',
    data: reports,
  });
});

export const getReportById = asyncHandler(async (req: Request, res: Response) => {
  const { id } = req.params;

  const report = await Report.findById(id);
  if (!report) {
    throw new AppError('Report not found', 404, 'REPORT_NOT_FOUND');
  }

  res.json({
    status: 'success',
    data: report,
  });
});